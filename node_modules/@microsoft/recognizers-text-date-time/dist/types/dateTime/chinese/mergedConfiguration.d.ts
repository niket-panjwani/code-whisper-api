import { BaseMergedExtractor, BaseMergedParser } from "../baseMerged";
import { ExtractResult, MetaData } from "@microsoft/recognizers-text";
import { DateTimeOptions } from "../dateTimeRecognizer";
import { DateTimeParseResult } from "../parsers";
import { StringMap } from "../utilities";
export declare class ChineseMergedExtractor extends BaseMergedExtractor {
    private readonly dayOfMonthRegex;
    private readonly sincePrefixRegex;
    private readonly sinceSuffixRegex;
    constructor(options: DateTimeOptions, dmyDateFormat?: boolean);
    extract(source: string, refDate: Date): ExtractResult[];
    protected addTo(destination: ExtractResult[], source: ExtractResult[], sourceStr: string): void;
    protected moveOverlap(destination: ExtractResult[], result: ExtractResult): ExtractResult[];
    protected checkBlackList(destination: ExtractResult[], source: string): ExtractResult[];
    protected addMod(ers: ExtractResult[], source: string): void;
    protected tryMergeModifierToken(er: ExtractResult, regex: RegExp, source: string, isPrefix?: boolean, potentialAmbiguity?: boolean): boolean;
    protected assignModMetadata(metadata: MetaData): MetaData;
    protected hasTokenIndex(source: string, regex: RegExp, isPrefix?: boolean): {
        matched: boolean;
        index: number;
    };
}
export declare class ChineseMergedParser extends BaseMergedParser {
    constructor(dmyDateFormat: boolean);
    parse(er: ExtractResult, refTime?: Date): DateTimeParseResult | null;
}
export declare class ChineseFullMergedParser extends BaseMergedParser {
    private readonly sincePrefixRegex;
    private readonly sinceSuffixRegex;
    constructor(dmyDateFormat?: boolean);
    parse(er: ExtractResult, refTime?: Date): DateTimeParseResult | null;
    protected dateTimeResolution(slot: DateTimeParseResult, hasRangeChangingMod: boolean): {
        [s: string]: StringMap[];
    };
    protected determineDateTimeType(type: string, hasMod: boolean): string;
    protected isDurationWithAgoAndLater(er: ExtractResult): boolean;
}
